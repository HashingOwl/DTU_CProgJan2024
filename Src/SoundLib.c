#include "stm32f30x_conf.h" // STM32 config


//Sets the voltage to val/128 of 3.3V with PWM to the buzzer
void setVoltage(uint8_t val) {
	TIM2->CCR3 = val; // Set compare register
	TIM2->EGR |= 0x01;
}



void disableMusic(void) {
	TIM16->DIER &= ~(0x0001); // Disable timer 16 interrupts
	TIM2->DIER &= ~(0x0001); // Disable timer 2 interrupts
}

void enableMusic(void) {
	TIM16->DIER |= 0x0001; // Enable timer 16 interrupts
	TIM2->DIER |= 0x0001; // Enable timer 2 interrupts
}

void TIM2_IRQHandler(void) {
	TIM2->SR &= ~0x0001; // Clear interrupt bit
}



uint8_t musicOnOff = 0;
void changeMusic(uint8_t boss) {
	if (boss == 1) {
		disableMusic();
	}
	if (musicOnOff){
		enableMusic();
		musicOnOff = 0;
	}
	else {
		disableMusic();
		musicOnOff = 1;
	}
}

volatile uint32_t beepCount = 0;
void playBeep(void) {
	beepCount = 1000;
	TIM16->ARR >>= 2;
}

#define nNotes 255
#define resetSize 1009
uint16_t notesT[255] = {0xfc7,0xe0e,0xd44,0xbd1,0xa87,0x7e3,0x8da,0xa87,0xfc7,0x7e3,0x8da,0xd44,0xe0e,0xfc7,0xe0e,0xd44,0xbd1,0xa87,0xbd1,0xd44,0xe0e,0xfc7,0xe0e,0xd44,0xe0e,0xfc7,0x10b7,0xe0e,0xfc7,0xe0e,0xd44,0xbd1,0xa87,0x7e3,0x8da,0xa87,0xfc7,0x7e3,0x8da,0xd44,0xe0e,0xfc7,0xe0e,0xd44,0xbd1,0xa87,0xbd1,0xd44,0xe0e,0xffff,0xd44,0xffff,0xbd1,0xa87,0xfc7,0xe0e,0xd44,0xbd1,0xa87,0x7e3,0x8da,0xa87,0xfc7,0x7e3,0x8da,0xd44,0xe0e,0xfc7,0xe0e,0xd44,0xbd1,0xa87,0xbd1,0xd44,0xe0e,0xfc7,0xe0e,0xd44,0xe0e,0xfc7,0x10b7,0xe0e,0xfc7,0xe0e,0xd44,0xbd1,0xa87,0x7e3,0x8da,0xa87,0xfc7,0x7e3,0x8da,0xd44,0xe0e,0xfc7,0xe0e,0xd44,0xbd1,0xa87,0xbd1,0xd44,0xe0e,0xffff,0xd44,0xffff,0xbd1,0xa87,0xbd1,0xa87,0x8da,0x7e3,0x8da,0xa87,0xbd1,0xa87,0xbd1,0xa87,0x8da,0x7e3,0x8da,0xa87,0xbd1,0xa87,0x8da,0x7e3,0x8da,0xd44,0xe0e,0x11b6,0xfc7,0x11b6,0xfc7,0xe0e,0xd44,0xbd1,0xa87,0xfc7,0xbd1,0xa87,0x8da,0x7e3,0x8da,0xa87,0xbd1,0xa87,0xbd1,0xa87,0x8da,0x7e3,0x8da,0xa87,0xbd1,0xa87,0x8da,0x7e3,0x8da,0xd44,0xe0e,0x11b6,0xfc7,0x11b6,0xfc7,0xe0e,0xd44,0xbd1,0xa87,0xfc7,0x5e8,0x543,0x46c,0x3f1,0x46c,0x543,0x5e8,0x543,0x5e8,0x543,0x46c,0x3f1,0x46c,0x543,0x5e8,0x543,0x5e8,0x543,0x5e8,0x6a1,0x706,0x6a1,0x8da,0x7e3,0x8da,0x7e3,0x706,0x6a1,0x5e8,0x6a1,0x543,0x7e3,0xbd1,0xa87,0x8da,0x7e3,0x8da,0xa87,0xbd1,0xa87,0xbd1,0xa87,0x8da,0x7e3,0x8da,0xa87,0xbd1,0xa87,0x7e3,0x706,0x6a1,0x706,0x7e3,0x8da,0xa87,0xbd1,0xa87,0xbd1,0xd44,0xe0e,0x11b6,0xfc7,0xfc7,0xffff,0xfc7,0xffff,0xfc7,0xffff,0xfc7,0xffff,0xfc7,0xffff,0xfc7,0xffff,0xfc7,0xffff,0xfc7,0xffff,0xfc7,0xffff,0xfc7,0xffff,0xfc7,0xffff,0xfc7,0xffff,0xffff,};
uint16_t notesR[255] = {0x294,0x2e4,0x310,0x370,0x7b9,0x528,0x497,0x7b9,0x528,0x528,0x497,0x310,0x2e4,0x294,0x2e4,0x310,0x370,0x7b9,0x370,0x310,0x2e4,0x294,0x2e4,0x310,0x2e4,0x294,0x26e,0x2e4,0x294,0x2e4,0x310,0x370,0x7b9,0x528,0x497,0x7b9,0x528,0x528,0x497,0x310,0x2e4,0x294,0x2e4,0x310,0x370,0x7b9,0x370,0x310,0x2e4,0xa50,0x310,0xa50,0x6e1,0xf73,0x294,0x2e4,0x310,0x370,0x7b9,0x528,0x497,0x7b9,0x528,0x528,0x497,0x310,0x2e4,0x294,0x2e4,0x310,0x370,0x7b9,0x370,0x310,0x2e4,0x294,0x2e4,0x310,0x2e4,0x294,0x26e,0x2e4,0x294,0x2e4,0x310,0x370,0x7b9,0x528,0x497,0x7b9,0x528,0x528,0x497,0x310,0x2e4,0x294,0x2e4,0x310,0x370,0x7b9,0x370,0x310,0x2e4,0xa50,0x310,0xa50,0x6e1,0xf73,0x370,0x3dc,0x497,0x294,0x24b,0x3dc,0x370,0x7b9,0x370,0x3dc,0x497,0x294,0x24b,0x3dc,0x370,0x7b9,0x497,0x528,0x497,0x310,0x2e4,0x24b,0x528,0x24b,0x294,0x2e4,0x310,0x370,0x3dc,0x528,0x370,0x3dc,0x497,0x294,0x24b,0x3dc,0x370,0x7b9,0x370,0x3dc,0x497,0x294,0x24b,0x3dc,0x370,0x7b9,0x497,0x528,0x497,0x310,0x2e4,0x24b,0x528,0x24b,0x294,0x2e4,0x310,0x370,0x3dc,0x528,0x6e1,0x7b9,0x92f,0x528,0x497,0x7b9,0x6e1,0xf73,0x6e1,0x7b9,0x92f,0x528,0x497,0x7b9,0x6e1,0xf73,0x6e1,0x7b9,0x6e1,0x621,0x2e4,0x9c,0x497,0xa50,0x497,0x528,0x5c9,0x621,0x370,0x310,0x7b9,0x528,0x370,0x3dc,0x497,0x294,0x24b,0x3dc,0x370,0x7b9,0x370,0x3dc,0x497,0x294,0x24b,0x3dc,0x370,0x7b9,0x528,0x5c9,0x621,0x5c9,0x528,0x497,0x7b9,0x370,0x3dc,0x370,0x310,0x2e4,0x24b,0x294,0xa5,0x294,0x339,0x294,0x1ef,0x294,0x339,0x294,0x339,0x294,0x1ef,0x294,0x339,0x294,0x339,0x294,0x1ef,0x294,0x339,0x294,0x339,0x294,0x294,0xa50,0xa500,};


#define stepSize 16
#define restLength 75
uint8_t currVol = 0;
int8_t direction = stepSize;
uint16_t rythmCount = 0;
uint16_t currentNote = 0;
uint8_t rest = 0;


void TIM1_UP_TIM16_IRQHandler(void) {
	if ((beepCount==0) && rest && (rythmCount > (notesR[currentNote]>>5))) {
		setVoltage(currVol);
		currVol += direction;
		if (currVol >= 128) {
				direction = -stepSize;
			}
		else if (currVol <= 0) {
			direction = stepSize;
		}
	}
	if (beepCount > 0) {
		setVoltage((beepCount&0x1)*32+(currVol>>1));
		beepCount--;
		if ((beepCount & 0x4) && rest) {
			currVol += direction;
		}
		if (currVol >= 128) {
				direction = -stepSize;
			}
		else if (currVol <= 0) {
			direction = stepSize;
		}
		if (beepCount == 0) {
			if(notesT[currentNote] != 0xffff) {
				rest = 1;
				TIM16->ARR=notesT[currentNote];
			}
			else {
				rest = 0;
				TIM16->ARR=resetSize;
			}
		}
	}
	rythmCount++;

	if (rythmCount == notesR[currentNote]){
		currentNote++;
		if (currentNote >= nNotes) {
			currentNote = 0;
		}
		if(notesT[currentNote] != 0xffff) {
			rest = 1;
			TIM16->ARR=notesT[currentNote];
		}
		else {
			rest = 0;
			TIM16->ARR=resetSize;
		}
		if (beepCount > 0) {
			TIM16->ARR >>= 2;
		}
		rythmCount = 0;
	}
	TIM16->SR &= ~0x0001; // Clear interrupt bit
}


void soundInit(void) {
	RCC->APB1ENR |= RCC_APB1Periph_TIM2; // Enable clock line to timer 2 and 16;

	TIM2->CR1 &= 0x0000; //Disable timer 2
	TIM2->ARR = 128;
	TIM2->PSC = 0; //
	TIM2->CR1 |= 0x0001; //Enable timer 2

	TIM2->DIER |= 0x0001; // Enable timer 2 interrupts
	NVIC_SetPriority(TIM2_IRQn, 14); // Set interrupt priority
	NVIC_EnableIRQ(TIM2_IRQn); // Enable interrupt


	TIM2->CCER &= ~TIM_CCER_CC3P; // Clear CCER register
	TIM2->CCER |= 0x00000001 << 8; // Enable OC3 output
	TIM2->CCMR2 &= ~TIM_CCMR2_OC3M; // Clear CCMR2 register
	TIM2->CCMR2 &= ~TIM_CCMR2_CC3S;
	TIM2->CCMR2 |= TIM_OCMode_PWM1; // Set output mode to PWM1
	TIM2->CCMR2 &= ~TIM_CCMR2_OC3PE;
	TIM2->CCMR2 |= TIM_OCPreload_Enable;
	TIM2->CCR3 = 0; // Set duty cycle to 50 %

	RCC->AHBENR |= RCC_AHBPeriph_GPIOB;	// Enable clock for GPIO Port B
	GPIOB->MODER |= (0x02 << (10 * 2));

	GPIO_PinAFConfig(GPIOB, GPIO_PinSource10, GPIO_AF_1);

	RCC->APB2ENR |= RCC_APB2Periph_TIM16; // Enable clock line to timer 16;
	TIM16->CR1 &= ~(0x09cF); //Disable timer 16
	TIM16->ARR = notesT[0];
	TIM16->PSC = 4; // Set prescale value
	TIM16->CR1 |= 0x0001; //Enable timer 16

	TIM16->DIER |= 0x0001; // Enable timer 16 interrupts

	NVIC_SetPriority(TIM1_UP_TIM16_IRQn, 15); // Set interrupt priority
	NVIC_EnableIRQ(TIM1_UP_TIM16_IRQn); // Enable interrupt
}


//Old system
/*
uint16_t notesT[92] = {0xe4,0xe4,0x87,0xb4,0x0,0xbf,0x0,0xcb,0xe4,0x10f,0xe4,0xcb,0x130,0x130,0x87,0xb4,0x0,0xbf,0x0,0xcb,0xe4,0x10f,0xe4,0xcb,0x142,0x142,0x87,0xb4,0x0,0xbf,0x0,0xcb,0xe4,0x10f,0xe4,0xcb,0x156,0x156,0x87,0xb4,0x0,0xbf,0x0,0xcb,0xe4,0x10f,0xe4,0xcb,0x71,0x71,0x71,0x0,0x71,0x0,0x71,0x87,0x0,0x87,0x71,0x71,0x71,0x0,0x65,0x0,0x5f,0x65,0x5f,0x65,0x87,0x71,0x65,0x0,0x71,0x71,0x71,0x0,0x65,0x0,0x5f,0x0,0x59,0x0,0x4b,0x0,0x59,0x43,0x43,0x43,0x59,0x43,0x4b,0x4b,};
uint16_t notesR[92] = {0x2,0x2,0x4,0x4,0x2,0x2,0x2,0x2,0x4,0x2,0x2,0x2,0x2,0x2,0x4,0x4,0x2,0x2,0x2,0x2,0x4,0x2,0x2,0x2,0x2,0x2,0x4,0x4,0x2,0x2,0x2,0x2,0x4,0x2,0x2,0x2,0x2,0x2,0x4,0x4,0x2,0x2,0x2,0x2,0x4,0x2,0x2,0x2,0x4,0x2,0x2,0x2,0x2,0x2,0x4,0x2,0x2,0x6,0x4,0x2,0x2,0x2,0x2,0x2,0x4,0x1,0x1,0x2,0x2,0x2,0x2,0x4,0x4,0x2,0x2,0x2,0x2,0x2,0x2,0x2,0x2,0x2,0x2,0x2,0x6,0x4,0x4,0x2,0x2,0x2,0x8,0xa,};

volatile uint8_t musicUpdateFlag = 0;

void TIM2_IRQHandler(void) {
	TIM2->SR &= ~0x0001; // Clear interrupt bit
}

void TIM1_UP_TIM16_IRQHandler(void) {
	musicUpdateFlag = 1;
	TIM16->SR &= ~0x0001; // Clear interrupt bit
}

void setFreqARR(uint16_t ARRval) {
	TIM2->ARR = ARRval; // Set auto reload value
	TIM2->CCR3 = ARRval>>1; // Set compare register
	TIM2->EGR |= 0x01;
}

void soundInit(void) {
	RCC->APB1ENR |= RCC_APB1Periph_TIM2; // Enable clock line to timer 2 and 4;

	TIM2->CR1 &= 0x0000; //Disable timer 15
	TIM2->ARR = 623;
	TIM2->PSC = 799; // Set prescale value. Set so one tick is 0.05ms (Not really anymore)
	TIM2->CR1 |= 0x0001; //Enable timer 15

	TIM2->DIER |= 0x0001; // Enable timer 15 interrupts
	NVIC_SetPriority(TIM2_IRQn, 14); // Set interrupt priority
	NVIC_EnableIRQ(TIM2_IRQn); // Enable interrupt


	TIM2->CCER &= ~TIM_CCER_CC3P; // Clear CCER register
	TIM2->CCER |= 0x00000001 << 8; // Enable OC3 output
	TIM2->CCMR2 &= ~TIM_CCMR2_OC3M; // Clear CCMR2 register
	TIM2->CCMR2 &= ~TIM_CCMR2_CC3S;
	TIM2->CCMR2 |= TIM_OCMode_PWM1; // Set output mode to PWM1
	TIM2->CCMR2 &= ~TIM_CCMR2_OC3PE;
	TIM2->CCMR2 |= TIM_OCPreload_Enable;
	TIM2->CCR3 = 623 / 2; // Set duty cycle to 50 %

	RCC->AHBENR |= RCC_AHBPeriph_GPIOB;	// Enable clock for GPIO Port B
	GPIOB->MODER |= (0x02 << (10 * 2));

	GPIO_PinAFConfig(GPIOB, GPIO_PinSource10, GPIO_AF_1);

	RCC->APB2ENR |= RCC_APB2Periph_TIM16; // Enable clock line to timer 15;
	TIM16->CR1 &= ~(0x09cF); //Disable timer 15
	TIM16->ARR = 3999;
	TIM16->PSC = 1599; // Set prescale value
	TIM16->CR1 |= 0x0001; //Enable timer 15

	TIM16->DIER |= 0x0001; // Enable timer 15 interrupts

	NVIC_SetPriority(TIM1_UP_TIM16_IRQn, 15); // Set interrupt priority
	NVIC_EnableIRQ(TIM1_UP_TIM16_IRQn); // Enable interrupt
}

uint16_t currNote = 0;
uint32_t count = 0;
uint8_t rest = 0;

void updateMusic() {
	if (rest) {
		TIM2->CR1 &= 0xfffe;
		TIM16->ARR = 50;
		rest = 0;
	}
	else {
		count++;
		if (count == notesR[currNote]*5) {
			TIM2->CR1 |= 1;
			TIM16->ARR = 3999;
			currNote++;
			currNote%=92;
			setFreqARR(notesT[currNote]);
			rest = 1;
			count = 0;
		}
	}
	musicUpdateFlag = 0;
}
*/
