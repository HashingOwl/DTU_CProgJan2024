#include "stm32f30x_conf.h" // STM32 config


//Sets the voltage to val/128 of 3.3V with PWM to the buzzer
void setVoltage(uint8_t val) {
	TIM2->CCR3 = val; // Set compare register
	TIM2->EGR |= 0x01;
}

void disableMusic(void) {
	TIM16->DIER &= ~(0x0001); // Disable timer 16 interrupts
	TIM2->DIER &= ~(0x0001); // Disable timer 2 interrupts
}

void enableMusic(void) {
	TIM16->DIER |= 0x0001; // Enable timer 16 interrupts
	TIM2->DIER |= 0x0001; // Enable timer 2 interrupts
}

void TIM2_IRQHandler(void) {
	TIM2->SR &= ~0x0001; // Clear interrupt bit
}

#define nNotes 91
#define resetSize 4039
uint16_t notesT[91] = {0x13e1,0x13e1,0xbd1,0xfc7,0xffff,0x10b7,0xffff,0x11b6,0x13e1,0x17a4,0x13e1,0x11b6,0x1a8a,0x1a8a,0xbd1,0xfc7,0xffff,0x10b7,0xffff,0x11b6,0x13e1,0x17a4,0x13e1,0x11b6,0x1c1e,0x1c1e,0xbd1,0xfc7,0xffff,0x10b7,0xffff,0x11b6,0x13e1,0x17a4,0x13e1,0x11b6,0x1dca,0x1dca,0xbd1,0xfc7,0xffff,0x10b7,0xffff,0x11b6,0x13e1,0x17a4,0x13e1,0x11b6,0x9f0,0x9f0,0x9f0,0xffff,0x9f0,0xffff,0x9f0,0xbd1,0xffff,0xbd1,0x9f0,0x9f0,0x9f0,0xffff,0x8da,0xffff,0x85b,0x8da,0x85b,0x8da,0xbd1,0x9f0,0x8da,0xffff,0x9f0,0x9f0,0x9f0,0xffff,0x8da,0xffff,0x85b,0xffff,0x7e3,0xffff,0x6a1,0xffff,0x7e3,0x5e8,0x5e8,0x5e8,0x7e3,0x5e8,0xd44,};
uint16_t notesR[91] = {0x13a,0x13a,0x421,0x318,0x18c,0x175,0x18c,0x160,0x274,0x108,0x13a,0x160,0xeb,0xeb,0x421,0x318,0x18c,0x175,0x18c,0x160,0x274,0x108,0x13a,0x160,0xde,0xde,0x421,0x318,0x18c,0x175,0x18c,0x160,0x274,0x108,0x13a,0x160,0xd1,0xd1,0x421,0x318,0x18c,0x175,0x18c,0x160,0x274,0x108,0x13a,0x160,0x4e9,0x274,0x274,0x18c,0x274,0x18c,0x4e9,0x210,0x18c,0x631,0x4e9,0x274,0x274,0x18c,0x2c1,0x18c,0x5d7,0x160,0x175,0x2c1,0x210,0x274,0x2c1,0x318,0x4e9,0x274,0x274,0x18c,0x2c1,0x18c,0x2eb,0x18c,0x318,0x18c,0x3ad,0x18c,0x948,0x842,0x842,0x421,0x318,0x421,0x108e,};

uint8_t currVol = 0;
int8_t direction = 32;
uint16_t rythmCount = 0;
uint16_t currentNote = 0;
uint8_t rest = 0;
#define stepSize 32
#define restLength 75

void TIM1_UP_TIM16_IRQHandler(void) {

	if (rest && rythmCount > (notesR[currentNote]>>5)) {
		setVoltage(currVol);
		currVol += direction;
		if (currVol >= 128) {
				direction = -stepSize;
			}
		else if (currVol <= 0) {
			direction = stepSize;
		}
	}

	rythmCount++;

	if (rythmCount == notesR[currentNote]){
		currentNote++;
		if (currentNote >= nNotes) {
			currentNote = 0;
		}
		if(notesT[currentNote] != 0xffff) {
			rest = 1;
			TIM16->ARR=notesT[currentNote];
		}
		else {
			rest = 0;
			TIM16->ARR=resetSize;
		}
		rythmCount = 0;
	}
	TIM16->SR &= ~0x0001; // Clear interrupt bit
}


void soundInit(void) {
	RCC->APB1ENR |= RCC_APB1Periph_TIM2; // Enable clock line to timer 2 and 16;

	TIM2->CR1 &= 0x0000; //Disable timer 2
	TIM2->ARR = 128;
	TIM2->PSC = 0; //
	TIM2->CR1 |= 0x0001; //Enable timer 2

	TIM2->DIER |= 0x0001; // Enable timer 2 interrupts
	NVIC_SetPriority(TIM2_IRQn, 14); // Set interrupt priority
	NVIC_EnableIRQ(TIM2_IRQn); // Enable interrupt


	TIM2->CCER &= ~TIM_CCER_CC3P; // Clear CCER register
	TIM2->CCER |= 0x00000001 << 8; // Enable OC3 output
	TIM2->CCMR2 &= ~TIM_CCMR2_OC3M; // Clear CCMR2 register
	TIM2->CCMR2 &= ~TIM_CCMR2_CC3S;
	TIM2->CCMR2 |= TIM_OCMode_PWM1; // Set output mode to PWM1
	TIM2->CCMR2 &= ~TIM_CCMR2_OC3PE;
	TIM2->CCMR2 |= TIM_OCPreload_Enable;
	TIM2->CCR3 = 32 / 2; // Set duty cycle to 50 %

	RCC->AHBENR |= RCC_AHBPeriph_GPIOB;	// Enable clock for GPIO Port B
	GPIOB->MODER |= (0x02 << (10 * 2));

	GPIO_PinAFConfig(GPIOB, GPIO_PinSource10, GPIO_AF_1);

	RCC->APB2ENR |= RCC_APB2Periph_TIM16; // Enable clock line to timer 16;
	TIM16->CR1 &= ~(0x09cF); //Disable timer 16
	TIM16->ARR = notesT[0];
	TIM16->PSC = 4; // Set prescale value
	TIM16->CR1 |= 0x0001; //Enable timer 16

	TIM16->DIER |= 0x0001; // Enable timer 16 interrupts

	NVIC_SetPriority(TIM1_UP_TIM16_IRQn, 15); // Set interrupt priority
	NVIC_EnableIRQ(TIM1_UP_TIM16_IRQn); // Enable interrupt
}




//Old system
/*
uint16_t notesT[92] = {0xe4,0xe4,0x87,0xb4,0x0,0xbf,0x0,0xcb,0xe4,0x10f,0xe4,0xcb,0x130,0x130,0x87,0xb4,0x0,0xbf,0x0,0xcb,0xe4,0x10f,0xe4,0xcb,0x142,0x142,0x87,0xb4,0x0,0xbf,0x0,0xcb,0xe4,0x10f,0xe4,0xcb,0x156,0x156,0x87,0xb4,0x0,0xbf,0x0,0xcb,0xe4,0x10f,0xe4,0xcb,0x71,0x71,0x71,0x0,0x71,0x0,0x71,0x87,0x0,0x87,0x71,0x71,0x71,0x0,0x65,0x0,0x5f,0x65,0x5f,0x65,0x87,0x71,0x65,0x0,0x71,0x71,0x71,0x0,0x65,0x0,0x5f,0x0,0x59,0x0,0x4b,0x0,0x59,0x43,0x43,0x43,0x59,0x43,0x4b,0x4b,};
uint16_t notesR[92] = {0x2,0x2,0x4,0x4,0x2,0x2,0x2,0x2,0x4,0x2,0x2,0x2,0x2,0x2,0x4,0x4,0x2,0x2,0x2,0x2,0x4,0x2,0x2,0x2,0x2,0x2,0x4,0x4,0x2,0x2,0x2,0x2,0x4,0x2,0x2,0x2,0x2,0x2,0x4,0x4,0x2,0x2,0x2,0x2,0x4,0x2,0x2,0x2,0x4,0x2,0x2,0x2,0x2,0x2,0x4,0x2,0x2,0x6,0x4,0x2,0x2,0x2,0x2,0x2,0x4,0x1,0x1,0x2,0x2,0x2,0x2,0x4,0x4,0x2,0x2,0x2,0x2,0x2,0x2,0x2,0x2,0x2,0x2,0x2,0x6,0x4,0x4,0x2,0x2,0x2,0x8,0xa,};

volatile uint8_t musicUpdateFlag = 0;

void TIM2_IRQHandler(void) {
	TIM2->SR &= ~0x0001; // Clear interrupt bit
}

void TIM1_UP_TIM16_IRQHandler(void) {
	musicUpdateFlag = 1;
	TIM16->SR &= ~0x0001; // Clear interrupt bit
}

void setFreqARR(uint16_t ARRval) {
	TIM2->ARR = ARRval; // Set auto reload value
	TIM2->CCR3 = ARRval>>1; // Set compare register
	TIM2->EGR |= 0x01;
}

void soundInit(void) {
	RCC->APB1ENR |= RCC_APB1Periph_TIM2; // Enable clock line to timer 2 and 4;

	TIM2->CR1 &= 0x0000; //Disable timer 15
	TIM2->ARR = 623;
	TIM2->PSC = 799; // Set prescale value. Set so one tick is 0.05ms (Not really anymore)
	TIM2->CR1 |= 0x0001; //Enable timer 15

	TIM2->DIER |= 0x0001; // Enable timer 15 interrupts
	NVIC_SetPriority(TIM2_IRQn, 14); // Set interrupt priority
	NVIC_EnableIRQ(TIM2_IRQn); // Enable interrupt


	TIM2->CCER &= ~TIM_CCER_CC3P; // Clear CCER register
	TIM2->CCER |= 0x00000001 << 8; // Enable OC3 output
	TIM2->CCMR2 &= ~TIM_CCMR2_OC3M; // Clear CCMR2 register
	TIM2->CCMR2 &= ~TIM_CCMR2_CC3S;
	TIM2->CCMR2 |= TIM_OCMode_PWM1; // Set output mode to PWM1
	TIM2->CCMR2 &= ~TIM_CCMR2_OC3PE;
	TIM2->CCMR2 |= TIM_OCPreload_Enable;
	TIM2->CCR3 = 623 / 2; // Set duty cycle to 50 %

	RCC->AHBENR |= RCC_AHBPeriph_GPIOB;	// Enable clock for GPIO Port B
	GPIOB->MODER |= (0x02 << (10 * 2));

	GPIO_PinAFConfig(GPIOB, GPIO_PinSource10, GPIO_AF_1);

	RCC->APB2ENR |= RCC_APB2Periph_TIM16; // Enable clock line to timer 15;
	TIM16->CR1 &= ~(0x09cF); //Disable timer 15
	TIM16->ARR = 3999;
	TIM16->PSC = 1599; // Set prescale value
	TIM16->CR1 |= 0x0001; //Enable timer 15

	TIM16->DIER |= 0x0001; // Enable timer 15 interrupts

	NVIC_SetPriority(TIM1_UP_TIM16_IRQn, 15); // Set interrupt priority
	NVIC_EnableIRQ(TIM1_UP_TIM16_IRQn); // Enable interrupt
}

uint16_t currNote = 0;
uint32_t count = 0;
uint8_t rest = 0;

void updateMusic() {
	if (rest) {
		TIM2->CR1 &= 0xfffe;
		TIM16->ARR = 50;
		rest = 0;
	}
	else {
		count++;
		if (count == notesR[currNote]*5) {
			TIM2->CR1 |= 1;
			TIM16->ARR = 3999;
			currNote++;
			currNote%=92;
			setFreqARR(notesT[currNote]);
			rest = 1;
			count = 0;
		}
	}
	musicUpdateFlag = 0;
}
*/
